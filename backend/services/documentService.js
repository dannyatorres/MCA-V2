// services/documentService.js - PDF Generation Service
// Centralized PDF generation with dynamic template replacement

const AWS = require('aws-sdk');
const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const { getDatabase } = require('./database');

// Initialize S3
const s3 = new AWS.S3({
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    region: process.env.AWS_REGION || 'us-east-1'
});

/**
 * Generates a PDF from the application template with dynamic field replacement
 * @param {string} conversationId - The conversation ID
 * @param {object} applicationData - All form fields to populate in the template
 * @param {string} ownerName - Fallback owner name for signature
 * @param {string} clientIp - Client IP address for digital signature
 * @returns {object} - { success, s3Key, filename, docId }
 */
exports.generateLeadPDF = async (conversationId, applicationData, ownerName, clientIp) => {
    let browser = null;
    try {
        console.log('ðŸš€ Starting PDF generation...');

        // 1. Prepare Signature Data
        const now = new Date();

        // Format: Nov-19-2025
        const datePart = now.toLocaleDateString('en-US', {
            month: 'short',
            day: '2-digit',
            year: 'numeric'
        }).replace(/ /g, '-').replace(',', '');

        // Format: 01:26:22 PM
        const timePart = now.toLocaleTimeString('en-US', {
            hour12: true,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });

        const fullTimestamp = `${datePart} ${timePart}`;

        // Owner 1 Signature Data
        const owner1FullName = `${applicationData.ownerFirstName || ''} ${applicationData.ownerLastName || ''}`.trim();

        // Owner 2 Signature Data
        const owner2FullName = `${applicationData.owner2FirstName || ''} ${applicationData.owner2LastName || ''}`.trim();

        // Merge signature data into applicationData
        const dataToMerge = {
            signature_name_1: owner1FullName || ownerName || '',
            timestamp_str_1: fullTimestamp,
            ip_str_1: clientIp,
            signature_name_2: owner2FullName || '',
            timestamp_str_2: owner2FullName ? fullTimestamp : '',
            ip_str_2: owner2FullName ? clientIp : '',
            signature_date: datePart
        };

        const finalData = { ...applicationData, ...dataToMerge };

        console.log('ðŸ” Digital signature data generated:', {
            owner1: owner1FullName,
            owner2: owner2FullName,
            timestamp: fullTimestamp,
            ip: clientIp
        });

        // 2. Load Template
        const templatePath = path.join(__dirname, '../templates/app5.html');
        if (!fs.existsSync(templatePath)) {
            throw new Error('Template not found: ' + templatePath);
        }

        let htmlContent = fs.readFileSync(templatePath, 'utf8');

        // 3. DYNAMIC REPLACEMENT LOOP
        // Automatically replaces all {{key}} placeholders with matching data values
        Object.keys(finalData).forEach(key => {
            if (finalData[key] !== undefined && finalData[key] !== null) {
                const regex = new RegExp(`{{${key}}}`, 'g');
                htmlContent = htmlContent.replace(regex, String(finalData[key]));
            }
        });

        // Clean up any remaining unreplaced placeholders
        htmlContent = htmlContent.replace(/{{[^}]+}}/g, '');

        console.log('ðŸ“ HTML template populated');

        // 4. Launch Puppeteer
        browser = await puppeteer.launch({
            headless: 'new',
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-gpu'
            ]
        });

        const page = await browser.newPage();
        console.log('ðŸŒ Puppeteer browser launched');

        // 5. Set content and wait for resources
        await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
        console.log('âœ… HTML content loaded in Puppeteer');

        // 6. Generate PDF
        const pdfBuffer = await page.pdf({
            format: 'A4',
            printBackground: true,
            margin: { top: '10mm', bottom: '10mm', left: '10mm', right: '10mm' }
        });

        console.log('ðŸ“„ PDF generated by Puppeteer');

        // 7. Upload to S3
        const safeLegalName = (finalData.legalName || 'Application').replace(/[^a-zA-Z0-9]/g, '_');
        const filename = `WCA_${safeLegalName}.pdf`;
        const s3Key = `generated/${conversationId}/${Date.now()}_${filename}`;

        await s3.putObject({
            Bucket: process.env.S3_DOCUMENTS_BUCKET,
            Key: s3Key,
            Body: pdfBuffer,
            ContentType: 'application/pdf'
        }).promise();

        console.log('â˜ï¸ PDF uploaded to S3:', s3Key);

        // 8. Save to database
        const db = getDatabase();
        const docId = uuidv4();

        await db.query(`
            INSERT INTO documents (
                id, conversation_id, s3_key, filename, original_filename,
                mime_type, file_size, created_at
            )
            VALUES ($1, $2, $3, $4, $5, 'application/pdf', $6, NOW())
        `, [docId, conversationId, s3Key, filename, filename, pdfBuffer.length]);

        console.log('ðŸ’¾ PDF metadata saved to database');

        return { success: true, s3Key, filename, docId };

    } catch (error) {
        console.error('âŒ PDF Generation Error:', error);
        throw error;
    } finally {
        if (browser) {
            await browser.close();
            console.log('ðŸ”’ Puppeteer browser closed');
        }
    }
};

/**
 * Generates populated HTML template (for preview or client-side PDF generation)
 * @param {object} applicationData - All form fields to populate
 * @param {string} ownerName - Fallback owner name
 * @param {string} clientIp - Client IP address
 * @returns {string} - Populated HTML string
 */
exports.generatePopulatedTemplate = (applicationData, ownerName, clientIp) => {
    // Prepare Signature Data
    const now = new Date();

    const datePart = now.toLocaleDateString('en-US', {
        month: 'short',
        day: '2-digit',
        year: 'numeric'
    }).replace(/ /g, '-').replace(',', '');

    const timePart = now.toLocaleTimeString('en-US', {
        hour12: true,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
    });

    const fullTimestamp = `${datePart} ${timePart}`;

    // Owner names
    const owner1FullName = `${applicationData.ownerFirstName || ''} ${applicationData.ownerLastName || ''}`.trim();
    const owner2FullName = `${applicationData.owner2FirstName || ''} ${applicationData.owner2LastName || ''}`.trim();

    // Merge signature data
    const dataToMerge = {
        signature_name_1: owner1FullName || ownerName || '',
        timestamp_str_1: fullTimestamp,
        ip_str_1: clientIp,
        signature_name_2: owner2FullName || '',
        timestamp_str_2: owner2FullName ? fullTimestamp : '',
        ip_str_2: owner2FullName ? clientIp : '',
        signature_date: datePart
    };

    const finalData = { ...applicationData, ...dataToMerge };

    // Load Template
    const templatePath = path.join(__dirname, '../templates/app5.html');
    if (!fs.existsSync(templatePath)) {
        throw new Error('Template not found: ' + templatePath);
    }

    let htmlContent = fs.readFileSync(templatePath, 'utf8');

    // Dynamic replacement loop
    Object.keys(finalData).forEach(key => {
        if (finalData[key] !== undefined && finalData[key] !== null) {
            const regex = new RegExp(`{{${key}}}`, 'g');
            htmlContent = htmlContent.replace(regex, String(finalData[key]));
        }
    });

    // Clean up unreplaced placeholders
    htmlContent = htmlContent.replace(/{{[^}]+}}/g, '');

    return htmlContent;
};
